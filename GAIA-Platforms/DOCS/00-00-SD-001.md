
### GAIA AIR Documentation System REST API & Components

**GenAI Proposal Status**: DRAFT - For Implementation Planning. This document outlines the components of the proposed GAIA AIR documentation system API, client utilities, and React UI components, based on the provided code snippets. It is subject to review, validation, and approval by authorized stakeholders.

---

## Overview

This document consolidates the proposed backend API, client-side utilities, and frontend React components designed to interact with the previously defined PostgreSQL database schema for managing GAIA AIR technical documentation. The system aims to provide hierarchical navigation, document retrieval (metadata and content), cross-reference resolution, revision history display, and search functionality.

---

### Server-Side API (`server.js`)

This Node.js/Express application serves as the backend REST API, interacting with the PostgreSQL database.

```javascript project="GAIA AIR Documentation API" file="server.js"
import express from 'express';
import pg from 'pg';
import cors from 'cors';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

// Configuration
const config = {
  port: process.env.PORT || 3000,
  db: {
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 5432,
    database: process.env.DB_NAME || 'gaia_air_docs',
    user: process.env.DB_USER || 'postgres',
    password: process.env.DB_PASSWORD || 'postgres',
  },
  documentBasePath: process.env.DOCUMENT_BASE_PATH || './documents' // Base path for file system content
};

// Initialize Express app
const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Create PostgreSQL connection pool
const pool = new pg.Pool(config.db);

// Test database connection
pool.query('SELECT NOW()', (err, res) => {
  if (err) {
    console.error('Database connection error:', err);
  } else {
    console.log('Database connected successfully at:', res.rows[0].now);
  }
});

// Middleware for error handling
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    status: 'error',
    message: 'An internal server error occurred',
    error: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

// API Routes

/**
 * @route GET /api/hierarchy
 * @description Get the complete document hierarchy tree
 */
app.get('/api/hierarchy', async (req, res, next) => {
  try {
    // Get all ATA chapters
    const chaptersResult = await pool.query(`
      SELECT chapter_id, title, description, domain_code
      FROM ATA_CHAPTER
      ORDER BY chapter_id
    `);

    const chapters = chaptersResult.rows;
    const hierarchy = [];

    // For each chapter, get its systems and subsystems
    for (const chapter of chapters) {
      // Get systems for this chapter
      const systemsResult = await pool.query(`
        SELECT system_id, title, description
        FROM SYSTEM
        WHERE chapter_id = $1
        ORDER BY system_id
      `, [chapter.chapter_id]);

      const systems = systemsResult.rows;
      const chapterNode = {
        id: chapter.chapter_id,
        type: 'chapter',
        title: chapter.title,
        description: chapter.description,
        domain_code: chapter.domain_code,
        children: []
      };

      // For each system, get its subsystems
      for (const system of systems) {
        // Get subsystems for this system
        const subsystemsResult = await pool.query(`
          SELECT subsystem_id, title, description
          FROM SUBSYSTEM
          WHERE system_id = $1
          ORDER BY subsystem_id
        `, [system.system_id]);

        const subsystems = subsystemsResult.rows;
        const systemNode = {
          id: system.system_id,
          type: 'system',
          title: system.title,
          description: system.description,
          children: []
        };

        // Add subsystems to system node
        for (const subsystem of subsystems) {
          // Count documents for this subsystem
          const docCountResult = await pool.query(`
            SELECT COUNT(*) as doc_count
            FROM DOCUMENT
            WHERE subsystem_id = $1
          `, [subsystem.subsystem_id]);

          const docCount = parseInt(docCountResult.rows[0].doc_count);

          const subsystemNode = {
            id: subsystem.subsystem_id,
            type: 'subsystem',
            title: subsystem.title,
            description: subsystem.description,
            documentCount: docCount // Add document count here
          };

          systemNode.children.push(subsystemNode);
        }

        chapterNode.children.push(systemNode);
      }

      hierarchy.push(chapterNode);
    }

    res.json({
      status: 'success',
      data: hierarchy
    });
  } catch (err) {
    next(err);
  }
});


/**
 * @route GET /api/hierarchy/:nodeId/documents
 * @description Get documents for a specific node in the hierarchy
 * @param {string} nodeId - ID of the node (chapter_id, system_id, or subsystem_id)
 */
app.get('/api/hierarchy/:nodeId/documents', async (req, res, next) => {
  try {
    const { nodeId } = req.params;
    let query;
    let params = [];

    // Determine node type based on ID format
    if (nodeId && nodeId.match(/^\d{2}$/)) { // Chapter (XX)
      query = `
        SELECT d.doc_id, d.title, d.doc_type, d.revision, d.status, d.file_path,
               d.created_date, d.modified_date, s.subsystem_id, s.title as subsystem_title,
               sys.system_id, sys.title as system_title
        FROM DOCUMENT d
        JOIN SUBSYSTEM s ON d.subsystem_id = s.subsystem_id
        JOIN SYSTEM sys ON s.system_id = sys.system_id
        WHERE sys.chapter_id = $1
        ORDER BY d.doc_id
      `;
      params = [nodeId];
    } else if (nodeId && nodeId.match(/^\d{2}-\d{2}$/)) { // System (XX-YY)
      query = `
        SELECT d.doc_id, d.title, d.doc_type, d.revision, d.status, d.file_path,
               d.created_date, d.modified_date, s.subsystem_id, s.title as subsystem_title
        FROM DOCUMENT d
        JOIN SUBSYSTEM s ON d.subsystem_id = s.subsystem_id
        WHERE s.system_id = $1
        ORDER BY d.doc_id
      `;
      params = [nodeId];
    } else if (nodeId && nodeId.match(/^\d{2}-\d{2}-\d{2}$/)) { // Subsystem (XX-YY-ZZ)
      query = `
        SELECT d.doc_id, d.title, d.doc_type, d.revision, d.status, d.file_path,
               d.created_date, d.modified_date
        FROM DOCUMENT d
        WHERE d.subsystem_id = $1
        ORDER BY d.doc_id
      `;
      params = [nodeId];
    } else {
      return res.status(400).json({
        status: 'error',
        message: 'Invalid node ID format'
      });
    }

    const result = await pool.query(query, params);

    res.json({
      status: 'success',
      data: result.rows
    });
  } catch (err) {
    next(err);
  }
});


/**
 * @route GET /api/documents/:docId
 * @description Get document metadata by ID
 * @param {string} docId - Document ID (Format: XX-YY-ZZ-III)
 */
app.get('/api/documents/:docId', async (req, res, next) => {
  try {
    const { docId } = req.params;

    // Validate docId format XX-YY-ZZ-III
    if (!docId || !docId.match(/^\d{2}-\d{2}-\d{2}-\d{3}$/)) {
      return res.status(400).json({
        status: 'error',
        message: 'Invalid document ID format. Expected XX-YY-ZZ-III.'
      });
    }

    // Get document metadata
    const docResult = await pool.query(`
      SELECT d.*,
             s.title as subsystem_title,
             sys.system_id, sys.title as system_title,
             a.chapter_id, a.title as chapter_title,
             dt.name as doc_type_name,
             p.project_name
      FROM DOCUMENT d
      JOIN SUBSYSTEM s ON d.subsystem_id = s.subsystem_id
      JOIN SYSTEM sys ON s.system_id = sys.system_id
      JOIN ATA_CHAPTER a ON sys.chapter_id = a.chapter_id
      JOIN DOCUMENT_TYPE dt ON d.doc_type = dt.type_code
      JOIN PROJECT p ON d.project_id = p.project_id
      WHERE d.doc_id = $1
    `, [docId]);

    if (docResult.rows.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Document not found'
      });
    }

    const document = docResult.rows[0];

    // Rename metadata_ to metadata in the response
    if ('metadata_' in document) {
        document.metadata = document.metadata_;
        delete document.metadata_;
    }


    res.json({
      status: 'success',
      data: document
    });
  } catch (err) {
    next(err);
  }
});

/**
 * @route GET /api/documents/:docId/content
 * @description Get document content by ID
 * @param {string} docId - Document ID
 */
app.get('/api/documents/:docId/content', async (req, res, next) => {
  try {
    const { docId } = req.params;

    // Validate docId format
     if (!docId || !docId.match(/^\d{2}-\d{2}-\d{2}-\d{3}$/)) {
      return res.status(400).json({
        status: 'error',
        message: 'Invalid document ID format. Expected XX-YY-ZZ-III.'
      });
    }

    // Get document metadata
    const docResult = await pool.query(`
      SELECT doc_id, file_path, content
      FROM DOCUMENT
      WHERE doc_id = $1
    `, [docId]);

    if (docResult.rows.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Document not found'
      });
    }

    const document = docResult.rows[0];
    let content;

    // If content is stored in the database, use that
    if (document.content) {
      content = document.content;
    } else {
      // Otherwise, try to read from file system
      try {
        // Resolve the absolute path relative to the server file
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = path.dirname(__filename);
        const filePath = path.resolve(__dirname, config.documentBasePath, document.file_path);
        // Ensure the resolved path stays within the intended base directory (basic security)
        if (!filePath.startsWith(path.resolve(__dirname, config.documentBasePath))) {
             throw new Error('Attempted access outside of designated document directory.');
        }
        console.log(`Attempting to read file from: ${filePath}`); // Debugging line
        content = await fs.readFile(filePath, 'utf8');
      } catch (fileErr) {
        console.error(`File system error for ${docId} at ${document.file_path}:`, fileErr); // Log specific error
        return res.status(404).json({
          status: 'error',
          message: 'Document content file not found or not accessible',
          error: process.env.NODE_ENV === 'development' ? fileErr.message : undefined
        });
      }
    }

    res.json({
      status: 'success',
      data: {
        doc_id: document.doc_id,
        content: content
      }
    });
  } catch (err) {
    next(err);
  }
});

/**
 * @route GET /api/documents/:docId/cross-references
 * @description Get cross-references for a document
 * @param {string} docId - Document ID
 */
app.get('/api/documents/:docId/cross-references', async (req, res, next) => {
  try {
    const { docId } = req.params;

     // Validate docId format
     if (!docId || !docId.match(/^\d{2}-\d{2}-\d{2}-\d{3}$/)) {
      return res.status(400).json({
        status: 'error',
        message: 'Invalid document ID format. Expected XX-YY-ZZ-III.'
      });
    }

    // Get cross-references where this document is the source
    const outgoingResult = await pool.query(`
      SELECT cr.reference_id, cr.ref_type, cr.description,
             d.doc_id as target_doc_id, d.title as target_title,
             d.doc_type as target_doc_type, d.revision as target_revision
      FROM CROSS_REFERENCE cr
      JOIN DOCUMENT d ON cr.target_doc_id = d.doc_id
      WHERE cr.source_doc_id = $1
    `, [docId]);

    // Get cross-references where this document is the target
    const incomingResult = await pool.query(`
      SELECT cr.reference_id, cr.ref_type, cr.description,
             d.doc_id as source_doc_id, d.title as source_title,
             d.doc_type as source_doc_type, d.revision as source_revision
      FROM CROSS_REFERENCE cr
      JOIN DOCUMENT d ON cr.source_doc_id = d.doc_id
      WHERE cr.target_doc_id = $1
    `, [docId]);

    res.json({
      status: 'success',
      data: {
        outgoing: outgoingResult.rows,
        incoming: incomingResult.rows
      }
    });
  } catch (err) {
    next(err);
  }
});

/**
 * @route GET /api/documents/:docId/history
 * @description Get revision history for a document
 * @param {string} docId - Document ID
 */
app.get('/api/documents/:docId/history', async (req, res, next) => {
  try {
    const { docId } = req.params;

     // Validate docId format
     if (!docId || !docId.match(/^\d{2}-\d{2}-\d{2}-\d{3}$/)) {
      return res.status(400).json({
        status: 'error',
        message: 'Invalid document ID format. Expected XX-YY-ZZ-III.'
      });
    }

    // Get current document info
    const currentDocResult = await pool.query(`
      SELECT doc_id, revision, version, modified_date
      FROM DOCUMENT
      WHERE doc_id = $1
    `, [docId]);

    if (currentDocResult.rows.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Document not found'
      });
    }

    const currentDoc = currentDocResult.rows[0];

    // Get document history
    const historyResult = await pool.query(`
      SELECT history_id, revision, version, change_description,
             changed_by, changed_date
      FROM DOCUMENT_HISTORY
      WHERE doc_id = $1
      ORDER BY changed_date DESC
    `, [docId]);

    // Combine current version with history
    const history = [
      {
        revision: currentDoc.revision,
        version: currentDoc.version,
        change_description: 'Current version',
        changed_date: currentDoc.modified_date,
        isCurrent: true
      },
      ...historyResult.rows.map(row => ({
        ...row,
        isCurrent: false
      }))
    ];

    res.json({
      status: 'success',
      data: history
    });
  } catch (err) {
    next(err);
  }
});


/**
 * @route GET /api/search
 * @description Search documents using the dedicated search function
 * @param {string} q - Search query
 */
app.get('/api/search', async (req, res, next) => {
  try {
    const { q } = req.query;

    if (!q) {
      return res.status(400).json({
        status: 'error',
        message: 'Search query parameter "q" is required'
      });
    }

    // Use the PostgreSQL search function 'search_documents'
    // Assumes the function handles formatting the query term internally
    const searchResult = await pool.query(
      "SELECT * FROM search_documents($1)",
      [q] // Pass the raw query term to the function
    );

    res.json({
      status: 'success',
      query: q,
      data: searchResult.rows // The function returns rows directly
    });
  } catch (err) {
    // Check for specific PostgreSQL errors if needed, e.g., syntax errors in tsquery
    if (err.code && err.code.startsWith('22')) { // Data exception errors (like invalid tsquery)
       return res.status(400).json({
        status: 'error',
        message: 'Invalid search query format.',
        error: process.env.NODE_ENV === 'development' ? err.message : undefined
       })
    }
    next(err); // Pass other errors to the generic handler
  }
});


/**
 * @route POST /api/documents/:docId/cross-references
 * @description Add a cross-reference between documents
 */
app.post('/api/documents/:docId/cross-references', async (req, res, next) => {
  try {
    const { docId } = req.params;
    const { targetDocId, refType, description } = req.body;

     // Validate docId format
     if (!docId || !docId.match(/^\d{2}-\d{2}-\d{2}-\d{3}$/)) {
      return res.status(400).json({
        status: 'error',
        message: 'Invalid source document ID format. Expected XX-YY-ZZ-III.'
      });
    }
    if (!targetDocId || !targetDocId.match(/^\d{2}-\d{2}-\d{2}-\d{3}$/)) {
        return res.status(400).json({
          status: 'error',
          message: 'Invalid target document ID format. Expected XX-YY-ZZ-III.'
        });
    }

    // Validate input
    const validRefTypes = ['DEPENDS_ON', 'REFERENCES', 'SUPERSEDES', 'IMPLEMENTS', 'VERIFIES'];
    if (!refType || !validRefTypes.includes(refType)) {
      return res.status(400).json({
        status: 'error',
        message: `Invalid reference type. Must be one of: ${validRefTypes.join(', ')}`
      });
    }

     if (docId === targetDocId) {
        return res.status(400).json({
          status: 'error',
          message: 'Source and target document IDs cannot be the same.'
        });
    }


    // Check if source document exists
    const sourceDocResult = await pool.query(`
      SELECT doc_id FROM DOCUMENT WHERE doc_id = $1
    `, [docId]);

    if (sourceDocResult.rows.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Source document not found'
      });
    }

    // Check if target document exists
    const targetDocResult = await pool.query(`
      SELECT doc_id FROM DOCUMENT WHERE doc_id = $1
    `, [targetDocId]);

    if (targetDocResult.rows.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Target document not found'
      });
    }

    // Check if reference already exists
    const existingRefResult = await pool.query(`
      SELECT reference_id FROM CROSS_REFERENCE
      WHERE source_doc_id = $1 AND target_doc_id = $2 AND ref_type = $3
    `, [docId, targetDocId, refType]);

    if (existingRefResult.rows.length > 0) {
      return res.status(409).json({
        status: 'error',
        message: 'Cross-reference already exists'
      });
    }

    // Add cross-reference
    const insertResult = await pool.query(`
      INSERT INTO CROSS_REFERENCE (source_doc_id, target_doc_id, ref_type, description)
      VALUES ($1, $2, $3, $4)
      RETURNING reference_id
    `, [docId, targetDocId, refType, description || null]); // Use null if description is not provided

    res.status(201).json({
      status: 'success',
      message: 'Cross-reference added successfully',
      data: {
        reference_id: insertResult.rows[0].reference_id,
        source_doc_id: docId,
        target_doc_id: targetDocId,
        ref_type: refType,
        description: description || null
      }
    });
  } catch (err) {
    // Check for unique constraint violation if needed (though the check above should prevent it)
    if (err.code === '23505') { // PostgreSQL unique violation code
        return res.status(409).json({ status: 'error', message: 'Cross-reference conflict.' });
    }
    next(err);
  }
});


/**
 * @route GET /api/stats
 * @description Get system statistics
 */
app.get('/api/stats', async (req, res, next) => {
  try {
    // Get counts of various entities
    const [
      chapterCount,
      systemCount,
      subsystemCount,
      documentCount,
      referenceCount
    ] = await Promise.all([
      pool.query('SELECT COUNT(*) FROM ATA_CHAPTER'),
      pool.query('SELECT COUNT(*) FROM SYSTEM'),
      pool.query('SELECT COUNT(*) FROM SUBSYSTEM'),
      pool.query('SELECT COUNT(*) FROM DOCUMENT'),
      pool.query('SELECT COUNT(*) FROM CROSS_REFERENCE')
    ]);

    // Get document counts by type
    const docTypeResult = await pool.query(`
      SELECT doc_type, COUNT(*) as count
      FROM DOCUMENT
      GROUP BY doc_type
      ORDER BY count DESC
    `);

    // Get document counts by status
    const docStatusResult = await pool.query(`
      SELECT status, COUNT(*) as count
      FROM DOCUMENT
      GROUP BY status
      ORDER BY count DESC
    `);

    res.json({
      status: 'success',
      data: {
        counts: {
          chapters: parseInt(chapterCount.rows[0].count),
          systems: parseInt(systemCount.rows[0].count),
          subsystems: parseInt(subsystemCount.rows[0].count),
          documents: parseInt(documentCount.rows[0].count),
          references: parseInt(referenceCount.rows[0].count)
        },
        documentsByType: docTypeResult.rows.map(row => ({
          type: row.doc_type,
          count: parseInt(row.count)
        })),
        documentsByStatus: docStatusResult.rows.map(row => ({
          status: row.status,
          count: parseInt(row.count)
        }))
      }
    });
  } catch (err) {
    next(err);
  }
});

// Start the server
const server = app.listen(config.port, () => {
  console.log(`GAIA AIR Documentation API server running on port ${config.port}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM signal received: closing HTTP server');
  server.close(() => {
    console.log('HTTP server closed');
    pool.end(() => {
      console.log('Database pool closed');
      process.exit(0);
    });
  });
});

export default app; // Export app for potential testing
```

---

### Client-Side API Utility (`api.js`)

This module provides functions for the frontend application to interact with the backend API.

```javascript project="GAIA AIR Documentation API" file="client/src/api.js"
/**
 * API client for the GAIA AIR Documentation System
 */

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000/api';

/**
 * Helper function to handle API responses
 * @param {Response} response - Fetch response object
 * @returns {Promise<Object>} Parsed JSON data
 */
async function handleResponse(response) {
  if (!response.ok) {
    let errorData;
    try {
      errorData = await response.json();
    } catch (e) {
      errorData = { message: response.statusText };
    }
    throw new Error(errorData.message || `API request failed with status ${response.status}`);
  }
  const data = await response.json();
  if (data.status !== 'success') {
    throw new Error(data.message || 'API request returned non-success status');
  }
  return data.data;
}

/**
 * Fetch the complete document hierarchy tree
 * @returns {Promise<Object>} Hierarchy tree
 */
export async function getHierarchy() {
  const response = await fetch(`${API_BASE_URL}/hierarchy`);
  return handleResponse(response);
}

/**
 * Fetch documents for a specific node in the hierarchy
 * @param {string} nodeId - ID of the node (chapter_id, system_id, or subsystem_id)
 * @returns {Promise<Array>} List of documents
 */
export async function getDocumentsForNode(nodeId) {
  const response = await fetch(`${API_BASE_URL}/hierarchy/${nodeId}/documents`);
  return handleResponse(response);
}

/**
 * Fetch document metadata by ID
 * @param {string} docId - Document ID
 * @returns {Promise<Object>} Document metadata
 */
export async function getDocumentMetadata(docId) {
  const response = await fetch(`${API_BASE_URL}/documents/${docId}`);
  return handleResponse(response);
}

/**
 * Fetch document content by ID
 * @param {string} docId - Document ID
 * @returns {Promise<Object>} Document content object { doc_id, content }
 */
export async function getDocumentContent(docId) {
  const response = await fetch(`${API_BASE_URL}/documents/${docId}/content`);
  return handleResponse(response);
}

/**
 * Fetch cross-references for a document
 * @param {string} docId - Document ID
 * @returns {Promise<Object>} Object containing 'outgoing' and 'incoming' arrays
 */
export async function getDocumentCrossReferences(docId) {
  const response = await fetch(`${API_BASE_URL}/documents/${docId}/cross-references`);
  return handleResponse(response);
}

/**
 * Fetch revision history for a document
 * @param {string} docId - Document ID
 * @returns {Promise<Array>} Revision history array
 */
export async function getDocumentHistory(docId) {
  const response = await fetch(`${API_BASE_URL}/documents/${docId}/history`);
  return handleResponse(response);
}

/**
 * Search documents
 * @param {string} query - Search query
 * @returns {Promise<Array>} Search results array
 */
export async function searchDocuments(query) {
  const response = await fetch(`${API_BASE_URL}/search?q=${encodeURIComponent(query)}`);
  return handleResponse(response);
}

/**
 * Add a cross-reference between documents
 * @param {string} sourceDocId - Source document ID
 * @param {string} targetDocId - Target document ID
 * @param {string} refType - Reference type
 * @param {string} [description] - Optional reference description
 * @returns {Promise<Object>} Created cross-reference object
 */
export async function addCrossReference(sourceDocId, targetDocId, refType, description = null) {
  const response = await fetch(`${API_BASE_URL}/documents/${sourceDocId}/cross-references`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      targetDocId,
      refType,
      description
    })
  });
  return handleResponse(response); // handleResponse checks for ok status and returns data
}

/**
 * Get system statistics
 * @returns {Promise<Object>} System statistics object
 */
export async function getSystemStats() {
  const response = await fetch(`${API_BASE_URL}/stats`);
  return handleResponse(response);
}
```

---

### Utility: Document Parser (`document-parser.js`)

*(Note: The full implementation of this parser is complex and depends heavily on the exact Markdown conventions used for metadata and references. This is a conceptual placeholder.)*

```javascript project="GAIA AIR Documentation API" file="utils/document-parser.js"
import matter from 'gray-matter'; // Library to parse frontmatter
import { Pool } from 'pg';
import path from 'path';
import fs from 'fs/promises';

// Placeholder for DB connection (in a real app, share the pool)
// const pool = new Pool({ /* config */ });

// Placeholder function to extract metadata and content
async function parseDocument(filePath) {
  try {
    const fileContent = await fs.readFile(filePath, 'utf8');
    const { data: metadata, content } = matter(fileContent); // Parses YAML frontmatter

    // --- Validate and Extract Metadata ---
    // Example: Extract doc_id, title, type, revision from metadata
    const doc_id = metadata.doc_id || path.basename(filePath).split('-').slice(4, 8).join('-'); // Infer from path if missing
    const title = metadata.title || path.basename(filePath, '.md');
    const doc_type = metadata.type || path.basename(filePath).split('-').slice(8, 9)[0];
    const revision = metadata.revision || path.basename(filePath).split('-').slice(9, 10)[0];
    // ... add more validation and extraction ...

    if (!doc_id || !title || !doc_type || !revision) {
        throw new Error(`Missing required metadata in ${filePath}`);
    }

    // --- Extract Cross-References (Example Regex) ---
    const referenceRegex = /\[REF:(\d{2}-\d{2}-\d{2}-\d{3}):(\w+)(?::(.+?))?\]/g;
    let match;
    const references = [];
    while ((match = referenceRegex.exec(content)) !== null) {
        references.push({
            target_doc_id: match[1],
            ref_type: match[2],
            description: match[3] || null,
        });
    }

    return {
      metadata: { doc_id, title, doc_type, revision /* ...other metadata */ },
      content, // The main Markdown content
      references // Array of extracted references
    };
  } catch (error) {
      console.error(`Error parsing ${filePath}:`, error);
      throw error; // Re-throw to be caught by the importer
  }
}

// Placeholder function to import a directory
async function importDocumentsFromDirectory(dirPath) {
  const results = [];
  try {
    const files = await fs.readdir(dirPath);
    for (const file of files) {
      if (path.extname(file).toLowerCase() === '.md') {
        const filePath = path.join(dirPath, file);
        try {
          const parsedData = await parseDocument(filePath);
          // --- Here you would interact with the database ---
          // 1. INSERT/UPDATE DOCUMENT table with parsedData.metadata and parsedData.content (if storing content in DB)
          // 2. INSERT entries into CROSS_REFERENCE table using parsedData.references
          // Example (Conceptual - requires actual DB connection and error handling):
          // await pool.query('INSERT INTO DOCUMENT (...) VALUES (...) ON CONFLICT (...) DO UPDATE ...', [...]);
          // for (const ref of parsedData.references) {
          //   await pool.query('INSERT INTO CROSS_REFERENCE (...) VALUES (...)', [parsedData.metadata.doc_id, ref.target_doc_id, ref.ref_type, ref.description]);
          // }
          console.log(`Successfully processed ${filePath}`);
          results.push({ filePath, success: true });
        } catch (error) {
          results.push({ filePath, success: false, error: error.message });
        }
      }
    }
  } catch (error) {
     console.error(`Error reading directory ${dirPath}:`, error);
     throw error; // Re-throw
  }
  return results;
}

export { parseDocument, importDocumentsFromDirectory };
```

---

### Utility: Command-Line Importer (`import-documents.js`)

This script uses the parser utility to import documents from a specified directory.

```javascript project="GAIA AIR Documentation API" file="utils/import-documents.js"
#!/usr/bin/env node

import { importDocumentsFromDirectory } from './document-parser.js'; // Assuming parser is in the same dir or adjust path
import path from 'path';
// import { fileURLToPath } from 'url'; // Needed if using import.meta.url

// Get command line arguments
const args = process.argv.slice(2);

if (args.length === 0) {
  console.error('Usage: node import-documents.js <directory-path>');
  process.exit(1);
}

const dirPath = path.resolve(args[0]); // Resolve to absolute path

// Run import
console.log(`Starting document import from directory: ${dirPath}...`);

importDocumentsFromDirectory(dirPath)
  .then(results => {
    const successCount = results.filter(r => r.success).length;
    const errorCount = results.filter(r => !r.success).length;

    console.log(`\nImport process completed.`);
    console.log(`  Successfully processed: ${successCount} documents.`);
    console.log(`  Failed to process:    ${errorCount} documents.`);

    if (errorCount > 0) {
      console.error('\nErrors occurred during import:');
      results.filter(r => !r.success).forEach(err => {
        console.error(`- File: ${path.basename(err.filePath)}`);
        console.error(`  Error: ${err.error}`);
      });
       process.exitCode = 1; // Indicate failure
    } else {
       console.log('\nAll documents processed successfully.');
       process.exitCode = 0; // Indicate success
    }
  })
  .catch(err => {
    console.error('\nCritical error during import process:', err);
    process.exit(1); // Indicate critical failure
  });
```

---

### Frontend Component: Hierarchy Tree (`HierarchyTree.jsx`)

React component to display the navigable document hierarchy.

```javascriptreact project="GAIA AIR Documentation API" file="client/src/components/HierarchyTree.jsx"
import React, { useState, useEffect } from 'react';
import { getHierarchy, getDocumentsForNode } from '../api'; // Assuming api.js is in ../api
import { ChevronRight, ChevronDown, FileText, Folder, Book } from 'lucide-react';
import './HierarchyTree.css'; // Assuming you have some basic CSS

const HierarchyTree = ({ onSelectSubsystem }) => { // Changed prop name for clarity
  const [hierarchy, setHierarchy] = useState([]);
  const [expandedNodes, setExpandedNodes] = useState({});
  const [selectedSubsystem, setSelectedSubsystem] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Fetch hierarchy on component mount
  useEffect(() => {
    const fetchHierarchy = async () => {
      try {
        setLoading(true);
        const data = await getHierarchy();
        setHierarchy(data);
        setError(null);
      } catch (err) {
        setError('Failed to load hierarchy: ' + err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchHierarchy();
  }, []);

  // Toggle node expansion
  const toggleNode = (nodeId) => {
    setExpandedNodes(prev => ({
      ...prev,
      [nodeId]: !prev[nodeId]
    }));
  };

  // Select a subsystem node and notify parent
  const selectSubsystem = (subsystem) => {
      setSelectedSubsystem(subsystem.id);
      if (onSelectSubsystem) {
          onSelectSubsystem(subsystem.id); // Notify parent about subsystem selection
      }
  };

  // Render a subsystem node
  const renderSubsystemNode = (subsystem) => {
      return (
        <div
          key={subsystem.id}
          className={`node-header subsystem-node ${selectedSubsystem === subsystem.id ? 'selected' : ''}`}
          onClick={() => selectSubsystem(subsystem)}
          title={subsystem.description || subsystem.title}
        >
          <span className="icon-spacer" /> {/* Spacer for alignment */}
          <Folder size={16} className="node-icon subsystem-icon" />
          <span className="node-title">
             {subsystem.id.split('-')[2]} - {subsystem.title}
             {subsystem.documentCount > 0 && <span className="doc-count">({subsystem.documentCount})</span>}
          </span>
        </div>
      );
  }

  // Render a system node
  const renderSystemNode = (system) => {
    const isExpanded = expandedNodes[system.id] || false;

    return (
      <div key={system.id} className="system-node">
        <div
          className={`node-header ${selectedSubsystem?.startsWith(system.id + '-') ? 'ancestor-selected' : ''}`} // Highlight if a child is selected
          onClick={() => toggleNode(system.id)}
          title={system.description || system.title}
        >
          <span className="expand-icon">
            {system.children.length > 0 ? (
              isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />
            ) : (
              <span className="icon-spacer" />
            )}
          </span>
           <Folder size={16} className="node-icon system-icon" />
           <span className="node-title">
              {system.id.split('-')[1]} - {system.title}
           </span>
        </div>

        {isExpanded && system.children.length > 0 && (
          <div className="node-children">
            {system.children.map(subsystem => renderSubsystemNode(subsystem))}
          </div>
        )}
      </div>
    );
  };


  // Render a chapter node
  const renderChapterNode = (chapter) => {
    const isExpanded = expandedNodes[chapter.id] || false;

    return (
      <div key={chapter.id} className="chapter-node">
        <div
          className={`node-header ${selectedSubsystem?.startsWith(chapter.id + '-') ? 'ancestor-selected' : ''}`} // Highlight if a child is selected
          onClick={() => toggleNode(chapter.id)}
           title={chapter.description || chapter.title}
        >
          <span className="expand-icon">
            {chapter.children.length > 0 ? (
              isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />
            ) : (
              <span className="icon-spacer" />
            )}
          </span>
          <Book size={16} className="node-icon chapter-icon" />
          <span className="node-title">
            {chapter.id} - {chapter.title}
          </span>
        </div>

        {isExpanded && chapter.children.length > 0 && (
          <div className="node-children">
            {chapter.children.map(system => renderSystemNode(system))}
          </div>
        )}
      </div>
    );
  };


  if (loading) {
    return <div className="loading">Loading hierarchy...</div>;
  }

  if (error) {
    return <div className="error">{error}</div>;
  }

  return (
    <div className="hierarchy-tree">
        {hierarchy.map(chapter => renderChapterNode(chapter))}
    </div>
  );
};

export default HierarchyTree;
```

*(CSS for HierarchyTree.jsx would be needed)*

---

### Frontend Component: Document Viewer (`DocumentViewer.jsx`)

React component to display the selected document's details.

```javascriptreact project="GAIA AIR Documentation API" file="client/src/components/DocumentViewer.jsx"
import React, { useState, useEffect } from 'react';
import {
  getDocumentMetadata,
  getDocumentContent,
  getDocumentCrossReferences,
  getDocumentHistory
} from '../api'; // Assuming api.js is in ../api
import { FileText, History, Link, Info } from 'lucide-react';
import ReactMarkdown from 'react-markdown';
import './DocumentViewer.css'; // Assuming you have some basic CSS

const DocumentViewer = ({ docId, onSelectDocument }) => { // Added onSelectDocument prop
  const [metadata, setMetadata] = useState(null);
  const [content, setContent] = useState(null);
  const [crossReferences, setCrossReferences] = useState(null);
  const [history, setHistory] = useState(null);
  const [activeTab, setActiveTab] = useState('content');
  const [loading, setLoading] = useState(false); // Initially false until docId is provided
  const [error, setError] = useState(null);

  // Fetch document data when docId changes
  useEffect(() => {
    if (!docId) {
        setMetadata(null);
        setContent(null);
        setCrossReferences(null);
        setHistory(null);
        setActiveTab('content');
        setLoading(false);
        setError(null);
        return;
    };

    const fetchDocumentData = async () => {
      try {
        setLoading(true);
        setActiveTab('content'); // Default to content tab on new doc load

        // Fetch all document data in parallel
        const [metadataData, contentData, refsData, historyData] = await Promise.all([
          getDocumentMetadata(docId),
          getDocumentContent(docId),
          getDocumentCrossReferences(docId),
          getDocumentHistory(docId)
        ]);

        setMetadata(metadataData);
        setContent(contentData.content); // Access the content field from the API response
        setCrossReferences(refsData);
        setHistory(historyData);
        setError(null);
      } catch (err) {
        console.error("Error fetching document data:", err); // Log error
        setError('Failed to load document: ' + err.message);
        // Clear previous data on error
        setMetadata(null);
        setContent(null);
        setCrossReferences(null);
        setHistory(null);
      } finally {
        setLoading(false);
      }
    };

    fetchDocumentData();
  }, [docId]);

  // Handle clicking on internal links generated by processContent
  const handleContentClick = (event) => {
    if (event.target.tagName === 'A' && event.target.getAttribute('href') === 'javascript:void(0)') {
      const targetDocId = event.target.textContent.match(/^(\d{2}-\d{2}-\d{2}-\d{3})/);
      if (targetDocId && targetDocId[1] && onSelectDocument) {
        event.preventDefault();
        onSelectDocument(targetDocId[1]);
      }
    }
  };


  // Process content to make cross-references clickable - More robust
  const processContent = (rawContent) => {
    if (!rawContent) return '';
    // Basic REF format: [REF:DOC_ID:TYPE:Optional Description]
    // Example: [REF:24-60-10-001:REFERENCES:See PMSC Spec]
    const refRegex = /\[REF:(\d{2}-\d{2}-\d{2}-\d{3}):(\w+)(?::(.*?))?\]/g;
    return rawContent.replace(refRegex, (match, targetDocId, refType, description) => {
        const display_text = description ? `${description} (${targetDocId})` : `${refType}: ${targetDocId}`;
        // Use data attributes to store info, make link clickable via JS handler
        return `<a href="javascript:void(0)" class="internal-doc-link" data-target-doc-id="${targetDocId}" title="Reference: ${refType} - ${targetDocId}">${display_text}</a>`;
    });
};


  // Render document metadata
  const renderMetadata = () => {
    if (!metadata) return <p>No metadata available.</p>;

    return (
      <div className="document-metadata">
        <h3>Document Metadata</h3>
        <table className="metadata-table">
          <tbody>
            <tr><th>Document ID:</th><td>{metadata.doc_id}</td></tr>
            <tr><th>Title:</th><td>{metadata.title}</td></tr>
            <tr><th>Type:</th><td>{metadata.doc_type} ({metadata.doc_type_name})</td></tr>
            <tr><th>Revision:</th><td>{metadata.revision}</td></tr>
            <tr><th>Status:</th><td>{metadata.status}</td></tr>
            <tr><th>Author:</th><td>{metadata.author || 'N/A'}</td></tr>
            <tr><th>Created:</th><td>{new Date(metadata.created_date).toLocaleString()}</td></tr>
            <tr><th>Modified:</th><td>{new Date(metadata.modified_date).toLocaleString()}</td></tr>
            <tr><th>Project:</th><td>{metadata.project_name} ({metadata.project_id})</td></tr>
            <tr><th>Chapter:</th><td>{metadata.chapter_id} - {metadata.chapter_title}</td></tr>
            <tr><th>System:</th><td>{metadata.system_id} - {metadata.system_title}</td></tr>
            <tr><th>Subsystem:</th><td>{metadata.subsystem_id} - {metadata.subsystem_title}</td></tr>
            <tr><th>File Path:</th><td>{metadata.file_path}</td></tr>
            {metadata.metadata && Object.keys(metadata.metadata).length > 0 && ( // Display JSONB metadata
              <tr>
                <th>Extra Metadata:</th>
                <td><pre>{JSON.stringify(metadata.metadata, null, 2)}</pre></td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    );
  };

  // Render cross-references
  const renderCrossReferences = () => {
    if (!crossReferences) return <p>No cross-reference data available.</p>;

    const renderRefList = (refs, direction) => {
        if (refs.length === 0) {
            return <p>No {direction.toLowerCase()} references</p>;
        }
        return (
             <ul className="reference-list">
              {refs.map(ref => {
                const keyId = ref.reference_id || `${ref.target_doc_id || ref.source_doc_id}-${ref.ref_type}`;
                const targetId = ref.target_doc_id || ref.source_doc_id;
                const targetTitle = ref.target_title || ref.source_title;
                const targetType = ref.target_doc_type || ref.source_doc_type;
                const targetRev = ref.target_revision || ref.source_revision;

                return (
                  <li
                    key={keyId}
                    className="reference-item"
                    onClick={() => targetId && onSelectDocument(targetId)} // Ensure targetId exists
                    title={`Click to view ${targetId}`}
                  >
                    <Link size={16} className="reference-icon" />
                    <div className="reference-info">
                      <div className="reference-title">
                        {targetTitle} ({targetId})
                      </div>
                      <div className="reference-meta">
                        {ref.ref_type} | {targetType} Rev {targetRev}
                        {ref.description && (
                          <span className="reference-description">: {ref.description}</span>
                        )}
                      </div>
                    </div>
                  </li>
                )
               })}
            </ul>
        )
    }


    return (
      <div className="cross-references">
        <h3>Cross References</h3>

        <div className="reference-section">
          <h4>Outgoing References (This document references...)</h4>
          {renderRefList(crossReferences.outgoing, 'Outgoing')}
        </div>

        <div className="reference-section">
          <h4>Incoming References (Referenced by...)</h4>
           {renderRefList(crossReferences.incoming, 'Incoming')}
        </div>
      </div>
    );
  };

  // Render revision history
  const renderHistory = () => {
    if (!history || history.length === 0) return <p>No revision history available.</p>;

    return (
      <div className="document-history">
        <h3>Revision History</h3>
        <ul className="history-list">
          {history.map((revision, index) => (
            <li key={revision.history_id || index} className={`history-item ${revision.isCurrent ? 'current' : ''}`}>
              <History size={16} className="history-icon" />
              <div className="history-info">
                <div className="history-title">
                  Revision {revision.revision} ({revision.version})
                  {revision.isCurrent && <span className="current-badge">Current</span>}
                </div>
                <div className="history-meta">
                  {new Date(revision.changed_date).toLocaleString()}
                  {revision.changed_by && ` by ${revision.changed_by}`}
                </div>
                {revision.change_description && revision.change_description !== 'Current version' && (
                  <div className="history-description">{revision.change_description}</div>
                )}
              </div>
            </li>
          ))}
        </ul>
      </div>
    );
  };

  // Main component render logic
  if (!docId) {
    return <div className="no-document">Select a document from the hierarchy or search results.</div>;
  }

  if (loading) {
    return <div className="loading">Loading document {docId}...</div>;
  }

  if (error) {
    return <div className="error">{error}</div>;
  }

  if (!metadata) {
       return <div className="error">Document metadata could not be loaded for {docId}.</div>;
   }


  return (
    <div className="document-viewer">
      <div className="document-header">
        <h2>{metadata?.title || 'Document'}</h2>
        <div className="document-id">{docId}</div>
        <div className="document-tabs">
          <button
            className={`tab ${activeTab === 'content' ? 'active' : ''}`}
            onClick={() => setActiveTab('content')}
          >
            <FileText size={16} /> Content
          </button>
          <button
            className={`tab ${activeTab === 'metadata' ? 'active' : ''}`}
            onClick={() => setActiveTab('metadata')}
          >
            <Info size={16} /> Metadata
          </button>
          <button
            className={`tab ${activeTab === 'references' ? 'active' : ''}`}
            onClick={() => setActiveTab('references')}
          >
            <Link size={16} /> References
            {crossReferences && (
              <span className="badge">
                {(crossReferences.outgoing?.length || 0) + (crossReferences.incoming?.length || 0)}
              </span>
            )}
          </button>
          <button
            className={`tab ${activeTab === 'history' ? 'active' : ''}`}
            onClick={() => setActiveTab('history')}
          >
            <History size={16} /> History
            {history && <span className="badge">{history.length}</span>}
          </button>
        </div>
      </div>

      <div className="document-content-area"> {/* Changed class name */}
        {activeTab === 'content' && (
           // Use dangerouslySetInnerHTML ONLY if you trust the source or sanitize it first.
           // Better: Use ReactMarkdown with components override for links
           <div className="markdown-content" onClick={handleContentClick}>
                <ReactMarkdown
                    children={content || '*No content available.*'}
                    components={{ // Override 'a' tag behavior for internal links
                         a: ({node, ...props}) => {
                            if (props.href === 'javascript:void(0)' && props.className === 'internal-doc-link') {
                                const targetDocId = node?.children?.[0]?.properties?.['data-target-doc-id'] || props['data-target-doc-id']; // Access data attribute
                                if (targetDocId && onSelectDocument) {
                                    return <a {...props} onClick={(e) => { e.preventDefault(); onSelectDocument(targetDocId); }} style={{cursor: 'pointer', color: 'blue', textDecoration: 'underline'}}>{props.children}</a>;
                                }
                            }
                            // Render external links normally
                             return <a {...props} target="_blank" rel="noopener noreferrer">{props.children}</a>;
                         }
                    }}
                />
           </div>
        )}

        {activeTab === 'metadata' && renderMetadata()}

        {activeTab === 'references' && renderCrossReferences()}

        {activeTab === 'history' && renderHistory()}
      </div>
    </div>
  );
};

export default DocumentViewer;

```

*(CSS for DocumentViewer.jsx would be needed)*

---

### Frontend Component: Document Search (`DocumentSearch.jsx`)

React component to handle searching documents via the API.

```javascriptreact project="GAIA AIR Documentation API" file="client/src/components/DocumentSearch.jsx"
import React, { useState } from 'react';
import { searchDocuments } from '../api'; // Assuming api.js is in ../api
import { Search, FileText } from 'lucide-react';
import './DocumentSearch.css'; // Assuming you have some basic CSS

const DocumentSearch = ({ onSelectDocument }) => {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [hasSearched, setHasSearched] = useState(false);

  // Handle search form submission
  const handleSearch = async (e) => {
    e.preventDefault();

    if (!query.trim()) {
        setResults([]);
        setHasSearched(true); // Show "No input" message or similar
        setError(null);
        return;
    };

    try {
      setLoading(true);
      setHasSearched(true);

      const searchResults = await searchDocuments(query);
      setResults(searchResults);
      setError(null);
    } catch (err) {
      console.error("Search failed:", err); // Log error
      setError('Search failed: ' + err.message);
      setResults([]);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="document-search">
      <form onSubmit={handleSearch} className="search-form">
        <div className="search-input-container">
          <input
            type="text"
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            placeholder="Search documents by title, content, or ID..."
            className="search-input"
          />
          <button type="submit" className="search-button" disabled={loading}>
            {loading ? '...' : <Search size={18} />}
          </button>
        </div>
      </form>

      {error && <div className="error">{error}</div>}

      {hasSearched && !loading && !error && (
        <div className="search-results">
          <h3>Search Results for "{query}"</h3>

          {results.length === 0 ? (
            <div className="no-results">No documents found matching your query.</div>
          ) : (
            <>
              <div className="results-count">{results.length} document(s) found</div>
              <ul className="results-list">
                {results.map(doc => (
                  <li
                    key={doc.doc_id}
                    className="result-item"
                    onClick={() => onSelectDocument(doc.doc_id)}
                    title={`Select document ${doc.doc_id}`}
                  >
                    <FileText size={16} className="result-icon" />
                    <div className="result-info">
                      <div className="result-title">{doc.title}</div>
                      <div className="result-meta">
                        {doc.doc_id} | Type: {doc.doc_type} | Chapter: {doc.chapter_id}
                      </div>
                    </div>
                    <div className="result-relevance" title={`Relevance Score: ${doc.relevance.toFixed(4)}`}>
                       {/* Simple relevance indicator - adjust as needed */}
                       Relevance: {Math.round(doc.relevance * 100)}%
                    </div>
                  </li>
                ))}
              </ul>
            </>
          )}
        </div>
      )}
    </div>
  );
};

export default DocumentSearch;

```

*(CSS for DocumentSearch.jsx would be needed)*

---

## Implementation Summary

This collection of code provides the foundational elements for the GAIA AIR Documentation System REST API and a basic React frontend structure:

### Server-Side Components

1.  **REST API Endpoints**: Implemented using Express.js and Node.js, providing CRUD (where applicable) and read operations for the documentation hierarchy, individual documents, metadata, content, cross-references, history, and search.
2.  **Database Interaction**: Uses the `pg` library to connect to and query the PostgreSQL database defined in the schema.
3.  **Error Handling**: Basic middleware for catching and responding to server errors.
4.  **(Conceptual) Document Parser Utility**: Outlines the logic needed to parse Markdown files, extract metadata (like frontmatter), identify cross-references, and prepare data for database import.
5.  **(Conceptual) Command-Line Import Tool**: Provides a script interface to utilize the parser for batch importing documents from a directory structure.

### Client-Side Components (React)

1.  **API Client (`api.js`)**: A JavaScript module containing functions to fetch data from the backend API endpoints, simplifying frontend component logic.
2.  **Hierarchical Navigation Tree (`HierarchyTree.jsx`)**: Renders the ATA chapter/system/subsystem structure fetched from the API, allowing users to expand/collapse nodes and select subsystems to view associated documents.
3.  **Document Viewer (`DocumentViewer.jsx`)**: Displays the selected document's content (rendering Markdown), metadata, cross-references (both incoming and outgoing), and revision history in separate tabs. Includes logic for handling internal document links.
4.  **Document Search (`DocumentSearch.jsx`)**: Provides a search input field and displays results fetched from the search API endpoint, allowing users to select documents directly from search results.

This structure provides a solid basis for building the interactive documentation system envisioned.
